# ADL v0.3 Concurrency: State, Materialization, Minimal API Contract

Issue: #240  
Epic: #108  
Burst: #235

## State Rules Under Concurrency

State visibility model (v0.3 design):

1. Branch snapshot
- Each branch reads from the same deterministic fork snapshot.
- No branch observes writes from sibling branches before join.

2. Branch write isolation
- Branch writes are staged per branch in branch-local buffers.
- Branch-local writes are not globally visible until join resolution.

3. Join materialization
- Join applies committed branch outputs in deterministic branch-key order.
- Conflicting writes are resolved by deterministic policy in v0.3:
  - `conflict_policy = fail_on_conflict`

## Materialization Ordering

For each branch in sorted branch-key order:
1. Validate branch output contract.
2. Materialize branch artifacts into branch namespace.
3. Stage state writes.

At join:
1. Validate join preconditions (required branches terminal).
2. Apply staged writes in deterministic order.
3. Emit join output artifacts.

## Minimal Runtime API Surface (Design Contract)

This burst does not implement, but defines the intended API touchpoints:

- Planner (`swarm/src/plan.rs`)
  - Introduce deterministic fork/join plan nodes.

- Executor (`swarm/src/execute.rs`)
  - Add concurrent-region execution entrypoint that uses deterministic branch ordering.
  - Add deterministic conflict detection for join materialization.

- Trace (`swarm/src/trace.rs`)
  - Add fork/join event types or deterministic encoding using existing event schema.

- Resolver (`swarm/src/resolve.rs`)
  - Ensure deterministic branch step-id derivation from plan.

## v0.3 Compatibility Contract

- v0.2 workflows remain sequential and unchanged.
- Concurrency features stay gated to v0.3 documents.
- Existing output contract semantics remain authoritative per step.

## Non-goals

- Transactional rollback across external side effects.
- Cross-run shared mutable state.
- Dynamic branch counts derived from non-deterministic runtime signals.
