# ADL v0.3 Concurrency Core (Design)

Issue: #238  
Epic: #108  
Burst: #235

## Goal
Define deterministic concurrency primitives and ordering guarantees for a v0.3 implementation burst.

## Concurrency Primitives

ADL v0.3 introduces two logical primitives at plan level:

1. `fork`
- A deterministic split from one parent step into multiple child branches.
- Child branches are ordered by branch key (stable lexical order).

2. `join`
- A deterministic synchronization point that consumes branch completion states.
- Join executes only after all required branches reach a terminal branch state.

## Mapping to Steps

- A planned concurrent region is represented as:
  - a fork coordinator step,
  - N branch steps,
  - one join coordinator step.
- Branch step ids are deterministic:
  - `<fork_step_id>::branch::<branch_key>`
- Join step id is deterministic:
  - `<fork_step_id>::join`

## Deterministic Trace Ordering Guarantees

For a single run, trace emission order is deterministic by construction:

1. `ForkStarted(fork_step_id)`
2. For each branch in sorted branch-key order:
- `StepStarted(branch_step_id)`
- `PromptAssembled(branch_step_id, hash)`
- `StepFinished(branch_step_id, success|failure)`
3. `JoinStarted(join_step_id)`
4. `JoinFinished(join_step_id, success|failure)`

Tie-breakers:
- If two events are logically simultaneous, order by `(step_id, event_kind_rank)`.
- `event_kind_rank`: `StepStarted < PromptAssembled < StepFinished`.

## v0.3 Scope

In scope:
- Plan-level fork/join semantics.
- Deterministic trace ordering across concurrent branches.
- Deterministic replay contract for plan + event sequence.

Out of scope:
- Parallel runtime optimization tuning.
- Distributed or multi-host scheduling.
- Non-deterministic branch prioritization.

## Compatibility

- v0.2 behavior remains unchanged.
- Any concurrency usage in v0.2 remains gated/fails fast as it does today.
